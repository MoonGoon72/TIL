# 1월 26일 오늘의 배움

## 객체 초기화, 객체 소멸시 호출 함수

- 객체를 만들 때 초기화 하는 방법
    - class 선언시 init()함수를 사용해 initializer를 설정해주어야함
    - 설계를 할 때 어떤 것들을 입력받아야 하는지를 알 수 있다.
    
- 객체가 소멸 될 때 호출되는 함수
    - deinit: 객체가 소멸할 때 실행됨, C++의 delete 와 같은듯
    - deinit이 실행되지 않으면 메모리 누수가 발생 (객체가 소멸되지 않았으니 실행이 안됐거든!)

## 메모리 참조, ARC

- 메모리에 참조될 때 늘어나는 수
    - ARC
    - 생성과 할당시 레퍼런스 카운트가 증가
    - 해제를 해줄 때 감소한다
    - 메모리 누수 처리 잘 해야함
    
- ARC를 늘리지 않는 방법
    
    강한 순환참조 시 메모리 누수 발생가능함
    
    - string: 아무것도 안쓸 때 기본 값, 참조할 때마다 ARC가 증가한다
    - weak: ARC 증가하지 않음, 값이 없을 때 옵셔널로 들어갈 수 있게 옵셔널로 선언함
    - unowned: ARC 증가하지 않음, 반드시 값이 들어간다고 해놓은 것이기때문에 옵셔널 선언 필요 없음, 위험함

## 클로저, protocol 활용

- 함수 밖에서도 사용할 수 있는 클로저
    - escaping closure
    
    ```swift
    class Boom {
    	let power: Int
    	var action: () -> ()
    	
    func explode(closure: @escaping () -> ()) {
    	closure()
    	action = closure
    }
    func act() {
    	action()
    }
    ```
    
    - `@escaping` 키워드를 사용하면 함수 내부의 클로저가 함수가 끝나더라도 남아있을 수 있게됨 (바깥에서 사용할 수 있음!)
- Protocol을 활용하는 방법 중 한가지
    - 여러 개의 공통적인 행동, 속성, 제약 등을 하나의 프로토콜로 정의해서 사용

## 타입 캐스팅, 제네릭

- 타입을 변화하는 방법 타입 캐스팅
    - as 키워드
        - 타입 캐스팅에 사용
    - is 키워드
        - 타입 확인할 때 사용
        
- 타입에 의존하지 않는 방법 제네릭
    - `func 함수명<제네릭타입명>(_ 인자1: 제네릭타입명, _ 인자2: 제네릭타입명) {}` 을 사용하면 제네릭 함수를 만든 것!