> [!note]
> ## 11. iOS 앱에서 네트워크 통신을 하는 방법에는 어떤 것들이 있나요?
> - `URLSession`의 기본 사용 방법을 설명해주세요.
> - 네트워크 요청 시 에러 처리는 어떻게 하나요?
> - 서드파티 라이브러리(예: Alamofire)를 사용하는 이유는 무엇인가요?
### iOS 앱에서 네트워크 통신을 하는 방법
#### 1. URLSession
- 애플에서 기본적으로 제공하는 네트워크 API
- 다양한 요청 방식(GET, POST 등)을 지원
- 장점: iOS에서 기본 제공되므로 별도의 라이브러리 추가 없이 Foundation을 통해 사용 가능하다.
- 단점: 추가적인 설정을 해주기 위해 코드가 복잡해질 수 있다.
#### 2. 서드파티 라이브러리 사용 (e.g. Alamofire, Moya ...)
- URLSession을 기반으로 만든 서드파티 네트워크 라이브러리
- 장점
	- **네트워크 요청과 응답 처리를 더 간단하고 직관적으로 처리 가능**
	- 코드가 간결해지고 가독성이 높아짐
	- JSON파싱, 파라미터 인코딩, 인증 등 추가 기능을 쉽게 사용 가능
- 단점: 서드파티 라이브러리를 사용하기 때문에, 유지보수와 업데이트에 신경을 써야한다.
### URL Loading System
> URL을 통해 네트워크에 존재하는 서버와 통신하는 기술

- URL Loading System은 **https와 같은 표준 프로토콜 혹은 custom 프로토콜을 사용하여, URL이 식별한 리소스에 대한 접근**을 제공한다.
- URL Loading System의 로딩(Loading)** 은 **비동기적(asynchronously)** 으로 수행되기 때문에 앱의 응답 속도를 저하시키거나 정지시키지 않고, 데이터나 오류가 도착하는대로 처리할 수 있다.
- URLSession에서 수행되는 task인 URLSessionTask 인스턴스는 데이터를 가져와서 앱에 반환하거나 파일을 다운로드하고, 데이터 및 파일을 업로드 가능하게 한다.
- URLSession을 통해 URLSessionTask는 여러 개 생성할 수 있다.
- URLSession을 설정하기 위해서는 URLSessionConfiguration 객체를 사용해야 한다.
- 하나의 세션을 사용하여 반복적으로 작업(Task)을 만들 수 있다.
	- e.g. 웹 브라우저의 일반 브라우징과 비공개 브라우징 사용을 위한 별도의 세션이 존재
	- 비공개 브라우징은 캐시를 하지 않는다.
	- ![](https://i.imgur.com/2X2yPIb.png)

### URLSession
관련 네트워크 데이터 전송 작업 그룹을 조정하는 개체
- URLSession 클래스는 URL로 지정된 엔드포인트에서 데이터를 다운로드하고, 엔드포인트로 데이터를 업로드 하기 위한 API를 제공합니다.

1. **세션 종류**
	- default: 가장 기본적인 통신 방법
	- ephemeral: 쿠키나 캐시, 인증을 디스크에 기록하지 않는 임시 세션 구성
	- background: 앱이 실행되지 않는 동안 백그라운드에서 콘텐츠의 업로드 및 다운로드 수행 가능

2. **task 종류**
	- Data task: NSData 객체를 사용하여 데이터를 주고 받습니다.
	- Upload task: Data task와 유사하지만, 데이터를 전송하고 앱이 실행되지 않는 동안 백그라운드 업로드를 지원합니다.
	- Download task: 파일 형태로 데이터를 검색하고 앱이 실행되지 않는 동안 백그라운드 다운로드를 지원합니다.
	- WebSocket task: RFC 6455로 정의된 웹소켓 프로토콜을 사용하여 TCP 및 TLS 메시지를 교환합니다.
#### URLSessionConfiguration
> URLSession의 행동이나 정책을 결정하는 클래스

**설정 옵션**
![](https://i.imgur.com/mp6TQUg.png)
timeout 설정, 셀룰러 사용 설정, 쿠키, 보안, 캐시, 백그라운드 정책 등을 설정할 수 있습니다.
#### Session Delegate
Session에서의 Task는 Delegate도 공유합니다. Delegate를 직접 구현하여 다양한 이벤트가 발생할 때 정보를 제공받습니다.
- 인증이 실패했을 때
- 서버로부터 데이터가 도착했을 때
- 데이터를 캐싱할 수 있게 되었을 때
> [!info]
> Important
> - Session 객체는 Delegate를 앱이 종료되거나 세션이 끝날 때까지 강한 참조를 유지합니다.
> - 따라서 세션을 invalidate 하지 않으면 앱이 종료될 때까지 메모리 누수가 발생합니다.

아래 코드처럼 특정 URLSessionDelegate를 만들어 커스텀 세션에 적용할 수 있습니다.
```swift
import Foundation

class MyURLSessionDataDelegate: NSObject, URLSessionDataDelegate {
    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        print("데이터 수신 중: \(data.count) bytes")
    }
    
    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: (any Error)?) {
        if let error {
            print("에러 발생함: \(error)")
        } else {
            print("요청 완료")
        }
    }
}

struct CustomTest {
    func customDelegateTest() {
        let delegate = MyURLSessionDataDelegate()
        let config = URLSessionConfiguration.default
        let session = URLSession(configuration: config, delegate: delegate, delegateQueue: .main)

        let url = URL(string: "https://jsonplaceholder.typicode.com/photos")!
        let task = session.dataTask(with: url)

        task.resume()
    }
}
```
### URLSession 기본
- 기본적으로 URLSession은 `shared`라는 싱글톤 세션을 통해 API 요청을 처리할 수 있습니다.
- 해당 방식은 사용자가 커스텀할 수 없어 제한적이지만 사용이 간단합니다.
- URLSessionConfiguration을 통해 URLSession을 커스텀 할 수 있습니다.
- URLSession을 통한 비동기 요청을 처리하기 위해서는 다음과 같이 두 가지 방법을 사용할 수 있습니다.
	- Completion Handler
		- 전통적인 방법이며 escaping closure를 통해 비동기 네트워크 통신의 결과값을 받아올 수 있습니다.
	- async/await
		- iOS 15 이후로 도입된 Swift concurrency를 사용한 방식입니다. 
		- (Xcode 13.2 부터 iOS 13도 async/await를 지원할 수 있게 되었습니다.)
#### URLSession의 기본 사용 방법
1. **URL 생성**: 요청을 보낼 URL을 정의합니다.
2. **URLSesison 인스턴스 생성**: URLSession의 싱글톤 세션인 `shared`를 사용하거나, 커스텀 세션을 생성할 수 있습니다.
3. **URLSessionTask 생성**: 요청을 보낼 URL을 바탕으로 dataTask, uploadTask, downloadTask 중 하나의 작업을 생성합니다.
4. **Task 실행**: 생성한 작업을 .resume()을 호출하여 실행합니다.
	- `swift concurrency`를 사용하는 방식의 경우 명시적으로 `.resume`을 호출하지 않더라도 `.data` 메서드 내부에서 자동으로 호출합니다.
#### URLRequest 사용 (POST나 헤더 필요 시)
```swift
guard let url = URL(string: "https://example.com) else { return }
var request = URLRequest(url: url)
request.httpMethod = "POST"
request.setValue("application/json", forHTTPHeaderField: "Content-Type")
request.httpBody = try? JSONSerialization.data(withJSONObject: ["name": "Swift"])

// dataTask 사용
let task = URLSession.shared.dataTask(with: request) { data, response, error in
	...
}
task.resume()
do {
	let (data, _) = try await URLSession.shared.data(for: request)
} catch {
	// error
}
```
> [!note]
> ## 12. 의존성 관리 도구(CocoaPods, Carthage, Swift Package Manager)의 종류와 차이점은 무엇인가요?
> - 각 도구의 사용 방법과 장단점을 설명해주세요.
> - 의존성 관리를 통해 얻을 수 있는 이점은 무엇인가요?
### 의존성 관리 도구
> 앱 개발을 위해 외부 라이브러리를 사용할 때, 프로젝트와 해당 라이브러리의 상관관계를 용이하게 관리해주는 도구
#### CoCoaPods
> iOS 개발에서 가장 오랫동안 사용된 의존성 관리 도구, **라이브러리를 쉽게 추가하고 관리**할 수 있도록 함

**사용 방법**
- 설치 방식: 라이브러리를 Xcode 프로젝트 파일(.xcworkspace)을 통해 통합하며, 의존성들이 모두 한 번에 설치
- 작동 방식: Podfile 파일에 의존성을 명시하고, pod install 명령어를 통해 의존성을 설치하거나 업데이트 가능
**장점**
- 대부분의 라이브러리가 지원하는 의존성 관리 도구
- 라이브러리 의존성 해결이 자동으로 이루어지므로, 여러 라이브러리 간의 충돌을 방지할 수 있다.
- 사용 빈도가 높은 만큼 자료가 풍부하여 초기 학습이 용이하다.
**단점**
- Xcode 프로젝트 파일을 .xcworkspace로 바꾸고, 프로젝트 설정을 CocoaPods 방식에 맞추어야 한다.
- 의존성 업데이트 속도가 느리고, Xcode 설정이 자동으로 변경되기 때문에 관리가 어려울 수 있다.
#### Carthage (카르티고)
> CocoaPods과 다르게 X**code 프로젝트 파일을 직접 수정하지 않고, 독립적인 프레임워크 파일을 빌드하여 연결**하는 의존성 관리 도구

**사용 방법**
- 설치 방식: 의존성을 프레임워크 파일로 빌드하고, **빌드된 프레임워크 파일을 Xcode 프로젝트에 직접 연결**하여 사용.
- 작동 방식: Cartfile 파일에 의존성을 작성하고, carthage update 명령어로 프레임워크를 다운로드하고 빌드한다. 빌드된 파일을 수동으로 프로젝트에 포함한다.
**장점**
- Xcode 프로젝트 파일을 직접 수정하지 않으므로, 설정이 독립적으로 유지됨
- 각 프레임워크를 독립적으로 빌드하기 때문에, CocoaPods 보다 빌드 시간이 짧을 수 있다.
- **Swift와 Objective-C 모두 지원**하며, 각종 Xcode 설정에 영향을 미치지 않아 팀 협업 시 유리
**단점**
- 의존성 파일을 수동으로 프로젝트에 포함해야 하므로, 설치와 통합 과정이 다소 복잡할 수 있다.
- 의존성 간 버전 충돌 해결이 자동화되지 않아 수동으로 관리해야 하는 경우가 많다.
#### Swift Package Manager
> Apple이 공식적으로 지원하는 의존성 관리 도구

**사용 방법**
- 설치 방식: Xcode의 File > Add Package Dependencies 메뉴에서 SPM 을 통해 프로젝트에 직접 의존성 추가 가능
- 작동 방식: SPM은 Git 저장소를 기반으로 하는 패키지를 관리하며, 의존성 버전을 자동으로 확인하여 설치. Package.swift 파일에서 패키지와 의존성을 관리
**장점**
- Apple이 공식적으로 지원하므로 Xcode와 Swift에 최적화되어 있어, Xcode 내에서 설정과 관리가 간편함
- Xcode에서 바로 라이브러를 검색하고, 설치가 가능하다.
**단점**
- Swift와 Objective-C 혼합 프로젝트에서는 완벽한 지원이 어려울 수 있음
- 기존 CocoaPods나 Carthage를 사용하는 일부 라이브러리들은 SPM 지원이 부족할 수 있음
#### 각 도구의 선택 기준
- **CocoaPods**: **라이브러리 지원**이 가장 많고 **의존성 관리가 자동화**되어 있어, 많은 라이브러리를 사용하는 프로젝트나 협업 시 CocoaPods가 유리함
- **Carthage**: 프로젝트 설정에 영향을 주지 않고 **독립적으로 프레임워크를 관리**하고 싶을 때 유용. 특히 **Xcode 설정을 유지**해야 하는 프로젝트나 특정 라이브러리 관리가 필요한 경우에 유리함
- **Swift Package Manager**: 최신 Swift 및 Xcode 통합이 필요하고, **Apple의 공식 지원**을 활용하고 싶을 때 적합. Objective-C가 필요하지 않은 Swift 저용 프로젝트에서 가장 간편하고 최적화된 선택
### 의존성 관리를 통해 얻을 수 있는 이점
의존성 관리는 **프로젝트의 외부 라이브러리와 프레임워크를 효과적으로 관리**하는 방법
이를 통해 코드의 재사용성, 유지보수성, 개발 생산성을 크게 향상시킬 수 있음
- **코드 재사용성 향상**
	- 외부 라이브러리를 손쉽게 추가하고 관리함으로써, 이미 검증된 라이브러리를 재사용 가능
	- **기본적인 기능 구현에 드는 시간 절약** 가능 (네트워크 요청, DB관리, 이미지 처리 등)
- **버전 관리 용이**
	- 의존성 관리 도구를 사용하면 **특정 버전을 고정하거나 원하는 버전으로 업데이트** 할 수 있어, 라이브러리의 안정성과 호환성을 보장 가능
		- 특정 버전에서 발생하는 오류를 피하거나, 새로운 기능이 추가된 최신 버전으로 쉽게 업데이트 가능. -> **프로젝트의 안정성과 유지보수성 향상**
- **의존성 충돌 방지**
	- CocoaPods와 같은 의존성 관리 도구는 **의존성 간의 버전 충돌을 자동으로 해결**하여 프로젝트에서 발생할 수 있는 문제를 최소화함
	- 여러 라이브러리를 사용할 때 종속성 문제가 발생할 수 있는데, 의존성 관리 도구는 이를 감지하고 적합한 버전으로 조정하여 **호환성 유지**
- **프로젝트 구조와 유지보수성 향상**
	- 의존성 관리 도구는 외부 라이브러리를 **자동으로 설치, 구성, 관리**하므로, 코드 구조가 일관되게 유지됨
	- 의존성 관리 도구는 프로젝트 내에서 라이브러리를 독립적으로 관리하여, 프로젝트의 구성과 빌드 설정이 깔끔하게 유지됨. 이로 인해 **프로젝트의 유지보수성이 높아지고, 협업시 충돌이 줄어드는 효과**를 얻을 수 있음
- **자동화된 설치 및 업데이트**
	- 의존성 관리 도구는 필요한 의존성을 자동으로 다운로드하고 설치해주며, 업데이트 시에도 명령어 한 줄로 모든 의존성을 최신 버전으로 맞출 수 있음
	- 이로 인해 **라이브러리 업데이트에 소요되는 시간을 줄여 개발 생산성을 높일 수 있음**
- **협업과 팀 생산성 향상**
	- 팀 내에서 동일한 의존성을 사용하고 버전을 맞출수 있으므로, 협업 과정에서 충돌이나 일관성 문제를 줄일 수 있음
	- **팀 전체의 개발 환경이 일관되게 유지 가능**
- **테스트 및 디버깅 편의성**
	- 의존성 관리 도구를 통해 업데이트 시 변경 사항을 추적하거나 특정 버전으로 되돌릴 수 있어, **디버깅이 수월하고 오류 발생 시 빠르게 대응**할 수 있음
	- 외부 라이브러리를 정리된 상태로 유지할 수 있으므로 테스트 환경에서도 안정적으로 동작
#### 결론
의존성 관리는 **프로젝트의 유지보수성과 코드 품질을 향상시키고, 개발 시간을 단축**할 수 있는 도구
의존성 관리 도구를 사용하면 **효율적인 버전 관리, 협업 환경의 일관성 유지, 라이브러리 업데이트 자동화** 등 여러 장점을 통해 프로젝트의 전반적인 **생산성과 안정성**을 높일 수 있음
> [!note]
> ## 13.Swift의 고차 함수(Higher-Order Functions)에 대해 설명해주세요.
> - `map`과 `flatMap`의 차이점은 무엇인가요?
> - `filter`, `reduce` 함수는 어떤 경우에 사용하나요?
> - `compactMap`은 어떤 역할을 하나요?

> [!note]
> ## 14. Git에서 브랜치(Branch)를 사용하는 이유와 장점은 무엇인가요?
> - 브랜치를 병합(Merge)하는 방법에는 어떤 것들이 있나요?
> - 브랜치 전략(예: Git Flow, Github Flow)에 대해 설명해주세요.
> - 충돌(Conflict)이 발생했을 때 해결 방법은 무엇인가요?

> [!note]
> ## 15. Swift의 에러 처리 방법에 대해 설명해주세요.
> - `throws`, `try`, `catch` 키워드의 사용 방법은 무엇인가요?
> - 옵셔널을 사용한 에러 처리와 `do-catch`를 사용하는 에러 처리의 차이는 무엇인가요?
> - 에러를 전파하는 방법은 무엇인가요?

