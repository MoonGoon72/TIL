> [!note]
> ## 21. 사용자 인터페이스(UI) 테스트와 단위(Unit) 테스트의 차이점은 무엇인가요?
> - XCTest 프레임워크를 사용하여 테스트를 작성하는 방법은 무엇인가요?
> - 테스트 주도 개발(TDD)의 장점은 무엇인가요?
> - 의존성 주입(Dependency Injection)을 활용하여 테스트 가능한 코드를 작성하는 방법은 무엇인가요?
### 단위(Unit) Test
#### 정의
- 개별 함수, 메서드, 클래스 등 개별적인 작은 단위의 코드가 기대한 대로 동작하는지 확인하는 테스트
- 보통 **비즈니스 로직**이나 **알고리즘**이 테스트 대상
#### 특징
- 빠르고 실행 비용이 낮음
- 테스트 대상을 잘게 나누고, **외부 의존성**은 **Mocking 등을 통해 격리**
- 코드 리팩터링이나 유지보수에 강력한 안전망 제공
### UI Test
#### 정의
- 실제 사용자처럼 앱의 **UI를 조작하고 화면상의 요소가 잘 동작하는지 검증**하는 테스트
- 버튼 클릭, 텍스트 입력, 화면 전환 등 **앱의 동작 흐름과 사용자 경험**을 테스트
#### 특징
- 실행 시간이 비교적 길고 리소스를 많이 사용
- 테스트 환경 설정(ex. 시뮬레이터, 실제 기기)이 필요
- 회귀 테스트 및 사용자 흐름 검증에 효과적
### 단위 (Unit) 테스트와 사용자 인터페이스 (UI) 테스트의 차이
| 항목             | 단위 테스트             | UI 테스트                    |
| -------------- | ------------------ | ------------------------- |
| 대상             | 함수, 메서드 등 코드 단위    | 화면 요소, 사용자 흐름             |
| 속도             | 빠름                 | 느림                        |
| 의존성            | 외부 의존성 제거(Mock 사용) | 실제 앱 동작 필요                |
| 신뢰성            | 로직의 정확성 검증         | 사용자 인터페이스의 작동 검증          |
| 도구             | XCTest             | XCUITest                  |
| 에러 발생 시 파악 용이성 | 비교적 쉬움 (로직 한정)     | 어렵거나 원인 추적 시간이 더 걸릴 수 있음 |
### XCTest 프레임워크를 사용하여 테스트를 작성하는 방법
![](https://i.imgur.com/oVF7vZf.png)
Targets -> Add a target 을 통해 UI Test 혹은 Unit Test를 추가할 수 있습니다.

- `setUp()`: 기본 값을 생성할 때 사용합니다. (객체 인스턴스 생성, db 초기화 등)
- `tearDown()`: 초기 상태로 복원할 때 사용합니다. (파일 닫기, 연결, 새로 만든 항목 제거 등)

##### XCTest 실행 흐름
![](https://i.imgur.com/qdnqGCX.png)
#### XCTAssert: 결과 값을 검증하는 방법
```swift
// 두 값이 같은지 or 다른지 검증합니다.
XCTAssertEqual(expression1: T, expression2: T, message: String)
XCTAssertNotEqual(expression1: T, expression2: T, message: String)

// 두 값이 지정한 범위 accuracy 사이에 있는지 확인합니다.
XCTAssertEqual(expression1: T, expression2: T, accuracy: T, message: String)
XCTAssertNotEqual(expression1: T, expression2: T, accuracy: T, message: String)

// 조건이 참인지 거짓인지 확인합니다.
XCTAssertTrue(expression: bool, message: String)
XCTAssertFalse(expression: bool, message: String)

// 값의 nil 여부를 확인합니다.
XCTAssertNil(expression: Any?, message: String)
XCTAssertNotNil(expression: Any?, message: String)
```
### 테스트 주도 개발 (TDD)
#### 장점
- **신뢰할 수 있는 코드**와 **빠른 피드백 루프** 제공
- 테스트 코드를 먼저 작성하면 자연스럽게 **명확한 요구사항 정의**가 이루어지고, 이를 기준으로 구현하게 되어 불필요한 코드가 줄어듦
- 리팩토링 시, 기존 기능이 깨지지 않았는지 **바로 확인**할 수 있어, 유지보수성과 확장성이 높아짐
- 디버깅 시간이 줄고, 버그를 초기에 잡을 수 있어 **전체 개발 효율 상승**
### 의존성 주입 (Dependecy Injection)을 활용하여 테스트 가능한 코드를 작성하는 방법
- 실제 객체 대신 **Mock 객체**를 주입하여, 외부 의존성을 테스트 가능한 형태(Mock)로 대체하여 단위 테스트 가능

> [!note]
> ## 22. Xcode에서 Instruments를 사용하여 앱의 성능을 분석하는 방법은 무엇인가요?
> - Time Profiler를 사용하여 성능 이슈를 찾는 방법을 설명해주세요
> - Allocations Instrument를 사용하여 메모리 누수를 탐지하는 방법은 무엇인가요?
> - Leaks Instrument를 사용하여 메모리 누수를 찾는 방법은 무엇인가요?
### Instruments
Xcode에서 제공하는 앱의 성능과 메모리 사용을 분석할 수 있는 도구.
#### Hang
Hang이란 사용자의 상호 작용을 처리하는데 눈어 띄게 지연되어 응답이 없는 기간을 의미합니다.
### Time Profiler
- 어떤 앱이 어떤 종류의 작업을 수행하고 있는지, 얼마나 많은 작업을 수행하는지 파악할 수 있는 도구.
- 시스템의 각 CPU를 일정한 간격으로 샘플링하는 방식으로 동작.
##### 함수 실행 시간
일반적으로 **실행하는데 1ms 미만이 걸리는 작업 청크**는**Dispatch나 async** 하는 것이 **권장되지 않습니다**. 앱에서 1ms 청크를 많이 계산하여 합산하면 중단이 발생하는 경우가 있을 수 있습니다. 이 경우 여러 작업 청크를 결합하여 함께 발송하면 각 항목에 대해 새 작업을 만들 필요가 없습니다.
#### 성능 이슈를 찾는 방법
![](https://i.imgur.com/1j41Zdr.png)
Xcode의 Run을 홀드하여 Profile로 변경합니다. 혹은 Instruments를 직접 실행해도 좋습니다.
![](https://i.imgur.com/8DvZifB.png)
Time Profiler 템플릿을 선택합니다.
![](https://i.imgur.com/05yIBBE.png)
Record 버튼을 누르면 기기(시뮬레이터)에서 앱이 실행됩니다.

<video controls src="https://docs-assets.developer.apple.com/published/df4386fda9ca839c15d4580e3936789d/02-02-start-recording.mp4" />

<video controls src="https://docs-assets.developer.apple.com/published/bcbc9eb4e9ab7e7bb61be74530f6684a/02-02-hang-recording.mp4" />
이런 식으로 Hang 이걸리는 부분을 찾을 수 있습니다.
![](https://i.imgur.com/r0siQ8a.png)
가장 무거운 스택 추적의 일부 함수 이름은 기본 텍스트 색상으로 표시되는 반면 다른 함수 이름은 회색으로 표시됩니다.
원본 코드에 대한 정보가 Instruments에 있다면 색상으로 표시됩니다. (개발자가 작성한 코드)

<video controls src="https://docs-assets.developer.apple.com/published/1d519114f76521ee2b0b972ef56c068a/03-02-select-heaviest-stack-trace-row.mp4" />
스크롤을 통해 함수 호출 또는 심볼을 찾아서 해당 부분에 의해 Hang이 유발됨을 알 수 있습니다.

<video controls src="https://docs-assets.developer.apple.com/published/7dad22b6dfd6131e38458e6569390e0d/05-01-drag-view-body-instrument-to-document.mp4" />
SwiftUI의 View와 관련된 경우 Instrument를 추가하여 확인 가능합니다.

<video controls src="https://docs-assets.developer.apple.com/published/0de616cbf5dae12e69bbb11d8db889b9/05-01-expand-thumbnail-body-duration-in-summary.mp4" />
[Apple - Instruments Tutorials](https://developer.apple.com/tutorials/instruments/ensuring-work-executes-in-a-background-thread)
### Allocations Instrument
- 앱이 생성하고 사용하는 객체의 수, 크기, 생명 주기를 분석하는 데 사용
![](https://i.imgur.com/Esxqc7d.png)
Instruments 실행 후 Allocations template을 선택합니다.

### Leaks Instrument
- Retain cycle, 강한 참조로 인해 메모리에서 해제되지 않는 객체를 탐지
![](https://i.imgur.com/vyP9IJ9.png)
Instruments 실행 후 Lecks template을 선택합니다.
![](https://i.imgur.com/ssNvGGe.png)
[출처](https://ios-development.tistory.com/604)
memory leak이 발생하는 경우 빨간색 x표시가 보입니다.

> [!note]
> ## 23. Swift의 제네릭(Generic)에 대해 설명해주세요.
> - 제네릭을 사용하는 이유는 무엇인가요?
> - 제네릭 타입 파라미터와 제약 조건을 설정하는 방법은 무엇인가요?
> - 제네릭을 사용할 때의 장점과 주의할 점은 무엇인가요?
### 제네릭 Generic
- 타입에 의존하지 않는 범용 코드를 작성할 때 사용
- 제네릭을 사용해 중복을 피하고, 코드를 유연하게 작성할 수 있다.
- Swift의 강력한 특징 중 하나

만약 두 `Int` 값을 바꾸는 `swapTwoInts(_:_:)`라는 함수를 구현해야 한다고 하면 다음과 같이 구현할 수 있습니다.
```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
	let temporaryA = a
	a = b
	b = temporaryA
}
```
이 때, 다른 자료형에도 동일하게 값을 바꾸는 함수가 필요하다고 할 때, 제네릭을 사용하지 않는다면 `swapTwoDouble(_:_:)`, `swapTwoString(_:_:)` 등의 `타입만 다르고 동작은 동일한` 함수를 따로 만들어주어야 합니다.

이때 사용할 수 있는것이 제네릭입니다.
```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
	let temporaryA = a
	a = b
	b = temporaryA
}
```
### 제네릭 타입 파라미터 & 제약 조건
#### 타입 파라미터
위 예시의 `T`를 `Type Parameter` 라고 합니다.
T라는 새로운 형식이 생성되는 것이 아닌, 실제 함수가 호출될 때 해당 매개변수의 타입으로 대체되는 **Placeholder** 입니다.
#### 타입 파라미터 이름 규칙
타입 파라미터는 제네릭 타입 간의 관계나 함수 간의 관계를 나타내기 위해 `Dictonary<Key, Value>`, `Array<Element>` 처럼 설명이 포함된 이름을 작성할 수 있습니다.
그러나 의미있는 관계가 없을 때에는 위 예시처럼 `T`, `U`, `V` 와 같은 단일 문자를 사용하여 이름을 지정하는 것이 일반적입니다.

타입 파라미터 이름으로는 **대문자 카멜 케이스(Upper Camel Case)** 를 사용하여, 값이 아닌 타입에 대한 지시자라는 것을 나타냅니다.
#### 타입 제약 (Type Constraints)
타입 파라미터가 특정 클래스를 상속하거나 특정 프로토콜 또는 프로토콜 구성을 준수해야 함을 지정해야 합니다.
즉, 제네릭 함수와 타입을 사용할 때, 특정 클래스의 하위 클래스나, 특정 프로토콜을 준수하는 타입만 받을 수 있도록 제약을 둘 수 있습니다.
```swift
func isSameValues<T>(_ a: T, _ b: T) -> Bool {
	return a == b  // Binary operator '==' can not be applied to two 'T' oerands
}
```
`==` 연산자는 a와 b의 타입이 Equatable 프로토콜을 준수할 때만 사용이 가능
지금은 a, b가 Equatable을 준수하지 않을 수 있기 때문에 컴파일 에러가 발생합니다.
따라서 다음과 같이 제네릭 타입에 제약을 둘 수 있습니다.
```swift
func isSameValues<T: Equatable>(_ a: T, _ b: T) -> Bool {
	return a == b
}
```
#### 제네릭 타입 확장 (Extending a Generic Type)
만약 제네릭 타입인 Stack이 다음과 같이 있다고 하자.
```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
```
이때 스택의 가장 상단 항목을 반환하는 `topItem`이라는 읽기 전용 계산 프로퍼티를 추가하고 싶다면 다음과 같이 구현할 수 있습니다.
```swift
extension Stack {
	var topItem: Element? {
		return items.isEmpty ? nil : items[items.count - 1]
	}
}
```
#### where 절이 있는 제네릭 확장
위 예제의 Stack의 Element가 Equatable을 채택할 때, 특정 값이 `topItem`인지 판단하는 함수가 필요하다고 해보자.
```swift
extension Stack where Element: Equatable {
    func isTop(_ item: Element) -> Bool {
        guard let topItem = items.last else {
            return false
        }
        return topItem == item
    }
}
```
위 코드는 Element가 Equatable을 채택한 경우 isTop 함수를 통해 해당 원소가 top인지 여부를 판단할 수 있게 됩니다.
Element가 Equatable을 채택하지 않은 스택에서 `isTop` 함수를 호출하려고 하면 에러가 발생합니다.
```swift
struct NotEquatable { }
var notEquatableStack = Stack<NotEquatable>()
let notEquatableValue = NotEquatable()
notEquatableStack.push(notEquatableValue)
notEquatableStack.isTop(notEquatableValue)  // Error
```
#### 제네릭 함수와 오버로딩
특정 타입일 경우 제네릭이 아닌 다른 함수로 구현하고 싶으면 제네릭 함수를 **오버로딩**하면 됩니다.
이 경우 타입이 지정된 함수가 제네릭 함수보다 우선순위가 높아서 타입이 오버로딩된 함수가 실행이 됩니다.
```swift
func swapValues<T>(_ a: inout T, _ b: inout T) {
    print("generic func")
    let tempA = a
    a = b
    b = tempA
}
 
func swapValues(_ a: inout Int, _ b: inout Int) {
    print("specialized func")
    let tempA = a
    a = b
    b = tempA
}

var a = 1
var b = 2
swapValues(&a, &b)          //"specialized func"
 
var c = "Hi"
var d = "Sodeul!"
swapValues(&c, &d)          //"generic func"
```
### 제네릭의 장점과 주의할 점
#### 제네릭 장점
1. 코드 재사용성 증가
	- 같은 기능을 여러 타입에 대해 중복 작성하지 않고, **하나의 제네릭 함수나 타입으로 재사용 가능**
2. 타입 안정성 확보
	- 제네릭을 사용하면 타입 정보를 컴파일 타입에 알 수 있어서, **런타임 타입 오류를 방지할 수 있음**
3. 추상화 수준 향상
	- 특정 프로토콜을 채택한 타입들만 허용하는 방식으로 **의미 있는 타입 제약을 걸 수 있음**
#### 주의할 점
1. 가독성 저하
	- 타입 매개변수가 많아지거나 복잡한 제약이 들어가는 **지나친 추상화는 오히려 가독성이 떨어지고 유지보수가 어려워질 수 있음** 
2. 제약 없는 제네릭은 타입 안정성의 이점을 잃을 수 있음
```swift
func printType<T>(_ value: T) {
	print(value)
}
// 어떤 타입이든 허용되지만, 의미 있는 제약이나 행동 정의가 없음
```
3. 프로토콜에서 제네릭을 사용하고 싶다면 **associatedtype**을 사용해야 함
```swift
protocol Stack {
	associatedtype value
	associatedtype equatableValue: Equatable // 제약도 줄 수 있다.
	
	func push(_ value: value)
	func pop() -> value?
	func top<T: Equatable>() -> T? // 메서드를 선언할 때는 제네릭 사용 가능
}

struct MyStack: Stack {
	typealias value = Int
	typealias equatableValue = Int
	
	func push(_ value: value) {...}
	func pop() -> value? {...}
}

struct MyStack2: Stack {
	func push(_ value: Int) {...}  // typealias 없이도 추론이 가능하면 생략 가능
	...
}
```
4. 디버깅과 에러 메시지가 복잡해질 수 있음
	- 제네릭이 깊어질수록 컴파일 에러 메시지가 어려워짐 -> 명확한 타입 추론이 어렵다면 명시적인 타입 사용이 도움됨
> [!note]
> ## 24. Swift의 클로저와 함수의 차이점은 무엇인가요?
> - 클로저가 일급 객체(First-Class Citizen)인 이유는 무엇인가요?
> - 함수형 프로그래밍 패러다임에서 클로저가 어떻게 활용되나요?
#### 클로저
- 익명 함수, 변수에 저장하거나 인자로 전달할 수 있는 **일급 객체**
- Swift에서 함수는 이름이 있는 클로저 클로저이지만, 보통 Unnamed Closure를 클로저라고 부른다.
- 클로저는 **캡처 가능**하므로 더 유연하게 사용 가능
- 클로저는 `in` 키워드를 사용해 매개변수와 본문을 구분하고, **컨텍스트에 따라 타입을 생략 가능**
#### 클로저가 일급 객체인 이유
- 변수에 할당할 수 있고, 함수의 **인자 및 반환값**으로 사용할 수 있으며, **동적으로 생성**하거나 **데이터 구조에 저장**가능
#### 함수형 프로그래밍 패러다임에서 클로저가 어떻게 활용되나요?
- 함수형 프로그래밍에서는 **고차 함수**와 클로저를 함께 사용해 로직을 추상화
- ex. `map`, `filter`, `reduce` 와 같은 표준 라이브러리는 함수 클로저를 인자로 받아서 로직을 정의
- 클로저를 전달함으로써 **상태를 변경하지 않고**, **순수 함수 기반**으로 데이터 처리를 구성할 수 있음
### 요약
- Swift에서 클로저는 익명 함수이며, 캡처 기능이 있어 스코프 밖의 값을 기억할 수 있는 특징이 있음
- Swift의 모든 함수는 사실 클로저의 한 형태이고, 클로저는 변수에 할당되거나 인자로 전달될 수 있어 일급 객체로 분류
- 함수형 프로그래밍에서는 클로저를 이용해 map, filter, reduce 와 같은 고차 함수를 구성하여, 반복 로직을 간결하고 선언적으로 표현 가능

> [!note]
> ## 25. 동시성 프로그래밍에서 동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?
> - iOS에서 비동기 작업을 처리하는 방법은 무엇인가요?
> - 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이점은 무엇인가요?
### 동기와 비동기
#### 동기
- Task가 순차적으로 실행됨
- 실행 시점과 종료 시점을 명확하게 파악 가능
#### 비동기
- Task가 병렬적으로 실행됨
- 종료 시점을 명확하게 파악(예측)할 수 없다.
#### iOS에서 비동기 작업을 처리하는 방법
1. Completion Handler
```swift
func fetchData(completion: @escaping (Data?) -> Void) { ... }
```
2. DispatchQueue (GCD)
```swift
DispatchQueue.global().async {
	// 작업
	DispatchQueue.main.async {
		// UI 업데이트
	}
}
```
3. Operation & OperationQueue
```swift
let queue = OperationQueue()
queue.addOperation { ... }
```
4. async/await (Swift 5.5+)
```swift
let data = try await fetchData()
```
5. Combine / RxSwift
- 리액티브 프로그래밍 패턴 사용 가능
### 세마포어와 뮤텍스
#### 세마포어
- 하나의 리소스에 접근하는 것을 n개까지 허용할 수 있도록 함, 동시 접근 개수 제한
#### 뮤텍스
- 하나의 리소스에는 하나만 접근 가능, 단일 접근 보장 (상호 배제)
- Race Condition 방지
#### 예시
```swift
let semaphore = DispatchSemaphore(value: 2)
semaphore.wait()
semaphore.signal()

let lock = NSLock()
lock.lock()
lock.unlock()
```
