> [!note]
> ## 16. 메모리 관리에서 강한 참조(Strong Reference)와 약한 참조(Weak Reference)의 차이점은 무엇인가요?
> - 순환 참조(Retain Cycle)가 발생하는 경우와 해결 방법은 무엇인가요?
> - 클로저에서 `[weak self]`와 `[unowned self]`의 차이는 무엇인가요?
### 강한 참조
강한 참조란 참조 타입 객체를 참조할 때 Reference Count를 증가시키는 참조입니다. 기본적으로 객체를 참조할 때는 강한 참조로 참조합니다.
### 약한 참조
약한 참조는 객체를 선언할 때 `weak` 이나 `unowned` 키워드를 통해 참조 타입 객체를 참조할 때 Reference Count를 증가시키지 않는 참조입니다.
- weak
	- 참조 대상이 **해제될 수 있는 경우**에 사용하는 약한 참조입니다. 참조가 해제되면 자동으로 nil이 되기 때문에 Optional로 선언해야 합니다.
- unowned
	- 참조 대상이 **항상 존재할 것이라는 가정** 하에 사용하는 약한 참조입니다. 참조 대상이 해제되었는데 접근하면 **런타임 에러가 발생**합니다.
### 순환 참조
참조 객체가 서로를 **강하게** 참조하는 상황을 의미합니다. 이 경우 서로를 참조하는 두 객체를 사용하는 곳이 없어지더라도 서로를 참조하고 있기 때문에 RC가 0이 되지 않아서 ARC에 의해 메모리에서 해제되지 않습니다.
#### 해결 방법
객체가 서로 참조하는 상황에서 둘 중 하나의 객체를 참조할 때 **약한 참조**를 통해 해결이 가능합니다.
### 클로저의 캡처 리스트
클로저에서 값을 캡처한다는 것은 클로저 내부에서 사용할 객체들의 주소를 참조하는 것을 의미합니다.
클로저의 캡처는 기본적으로 강한 참조를 통해 캡처를 합니다. 이 경우 클로저가 상위 객체를 강한 참조하고, 상위 객체가 클로저를 강한 참조하게 되면 **순환 참조(Retain Cycle)** 가 발생합니다.

이를 방지하기 위해 클로저는 캡처 리스트를 사용할 수 있습니다.
캡처 리스트는 클로저가 외부 변수나 상수를 캡처할 때, 해당 변수나 상수를 어떻게 관리할 지 명시하는 기능 입니다. 
`[]` 내부에 변수를 넣어놓으면 값 타입의 경우 immutable한 복사본을 생성합니다.
참조 타입의 경우에는 `weak`, `unowned`를 사용하여 참조 강도를 명시할 수 있습니다.
#### 예시
```swift
final class ViewController: UIViewController {
	var name = "MoonGoon"
	func fetchData() {
		NetworkManager.shared.load { [weak self] result in
			guard let self else { return }
			print("\(self.name) received result: \(result))
		}
	}
}
```
- ViewController -> closure를 강한 참조
- `[weak self]`를 사용하지 않았다면 closure -> self (ViewController)를 강한 참조
	- 서로가 서로를 강하게 참조하여 순환 참조가 발생할 수 있었습니다.
- `[weak self]`를 사용하여 closure -> self (ViewController)를 약한 참조
	- ViewController가 사라지면 클로저도 자동으로 종료됩니다.
#### `[weak self]`
해당 캡처리스트는 클로저가 자신을 캡처할 때 약한 참조를 한다는 것을 의미합니다.
이 경우 클로저에서는 약한 참조를 하기 때문에 상위 객체가 Closure를 강한 참조한다고 하더라도 순환 참조가 발생하지 않습니다.
#### `[unowned self]`
`[unowned self]`로 self를 캡처하면 약한 참조이지만 self는 반드시 값을 지닌다고 판단하고 옵셔널 바인딩이 필요가 없어집니다.
self가 반드시 살아있음이 보장될 때 사용해야 합니다.
> [!note]
> ## 17. iOS 앱에서 Multi-threading을 구현하는 방법은 무엇인가요?
> - `DispatchQueue`와 `OperationQueue`의 차이점은 무엇인가요?
> - 동시성 프로그래밍에서 Race Condition을 방지하는 방법은 무엇인가요?
> - 메인 스레드에서 UI 업데이트를 해야 하는 이유는 무엇인가요?

> [!note]
> ## 18. UIKit에서 TableView와 CollectionView의 차이점은 무엇인가요?
> - 셀(Cell)의 재사용(Reusability)은 어떻게 구현되나요?
> - 동적인 셀 높이(Dynamic Cell Height)를 설정하는 방법은 무엇인가요?
> - CollectionView의 레이아웃을 커스터마이징하는 방법은 무엇인가요?

> [!note]
> ## 19. ARC(Automatic Reference Counting)의 동작 원리는 무엇인가요?
> - Retain Cycle이 발생하지 않도록 방지하는 방법은 무엇인가요?
> - `deinit` 메서드는 언제 호출되며, 어떤 역할을 하나요?

> [!note]
> ## 20. 상속(Inheritance)과 프로토콜(Protocol)의 차이점은 무엇인가요?
> - 클래스 상속을 사용할 때의 장단점은 무엇인가요?
> - 다중 상속(Multiple Inheritance)이 불가능한 이유는 무엇인가요?
> - 프로토콜 준수(Conformance)를 통해 다형성을 구현하는 방법은 무엇인가요?
