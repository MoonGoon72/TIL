> [!note]
> ### 21. iOS에서 메모리 사이즈와 관련된 개념과 고려 사항에 대해 설명해주세요.
> - 메모리 정렬(Alignment)이 성능에 미치는 영향은 무엇인가요?
#### iOS에서 메모리 사이즈와 관련된 개념과 고려 사항
iOS에서는 메모리 사용량을 최소화하고, 성능을 최적화 하는 것이 중요함. 메모리가 부족하면 앱이 느려지거나 종료될 수 있기 때문.

**페이지와 크기**
- iOS에서는 메모리를 **페이지 단위 (보통 16K)** 로 관리
#### 메모리 정렬(Alignment)이란?
메모리 정렬은 CPU가 **데이터를 효율적으로 읽고 쓰도록 메모리를 배치하는 방식**.
이를 잘 못할시, **성능 저하(Cache Miss, Unaligned Access)** 와 **메모리 낭비(Padding)** 이 발생할 수 있음
- 정렬(Alignment)이란?
	- CPU는 메모리에서 데이터를 읽을 때, 특정 크기(e.g. 4bye, 8bye)에 맞춰 읽음
	- 데이터가 정렬되어 있지 않으면 CPU가 여러 번 접근해야 하므로 성능이 저하됨
		- 정렬된 값의 경우 CPU가 별도 연산 없이 레지스터 저장 가능
		- 정렬되어 있지 않으면 n byte 앞 뒤로 접근하고 shift 연산을 통해 레지스터 저장
- 정렬이 성능에 미치는 영향
	- 메모리 접근 속도 증가: 정렬된 데이터는 CPU 캐시와 메모리 버스에서 빠르게 처리
	- 오버헤드 감소: 정렬된 데이터는 CPU가 한 번에 접근 가능하므로 성능 향상
- 패딩 문제
	- 구조체의 필드들이 정렬되도록 추가적인 빈 공간(패딩) 이 삽입될 수 있음
	```swift
	struct Misaligned {
		var a: Int8  // 1byte
		var b: Int32 // 4byte
		var c: Int8  // 1byte
	}
	// 예상 크기: 1 + 4 + 1 = 6byte
	// 실제 크기: (1 + 3) + 4 + (1 + 3) = 12byte
	```
	- 정렬을 고려하여 필드 순서를 변경하면 다음과 같이 최적화 가능
	```swift
	struct Aligned {
		var b: Int32 // 4byte
		var a: Int8  // 1byte
		var c: Int8  // 1byte
	}
	// 크기: 4 + (1 + 1 + 2) = 8byte
	```

> [!note]
> ### 22. iOS 디바이스의 메모리 제약과 앱 메모리 제한에 대해 설명해주세요.
> - 메모리 경고(Memory Warning)가 발생하면 어떤 조치를 취해야 하나요?
#### iOS 디바이스의 메모리 제약
**iOS의 물리적 메모리 한계**
- **iOS는 물리적 메모리가 제한된 환경**이므로, 앱이 메모리를 과도하게 사용하면 iOS가 개입하여 강제 종료 가능
**앱의 메모리 제한**
- iOS는 앱당 메모리 사용을 제한(디바이스 모델, iOS 버전마다 다름)
- iOS는 **swap(가상 메모리)이 없기 때문에** 앱이 너무 많은 메모리를 사용하면 종료
#### 메모리 경고(Memory Warning)가 발생했을 때 조치
**메모리 경고 발생 조건**
- **사용 가능한 메모리가 부족할 때** iOS가 AppDelegate 및 UIViewController에 **메모리 경고를 보냄**

**대응 방법**
1. 불필요한 리소스 정리
	- 사용하지 않는 이미지, 캐시 데이터, 객체 등을 해제
2. 메모리 사용량 최적화
	- 대용량 객체 (Data, UIImage)는 필요할 때만 로드하고 즉시 제거
3. 백그라운드 작업 최적화
	- 비활성화된 뷰 컨트롤러의 리소스를 해제 
4. Lazy Loading 사용
	- 즉시 필요하지 않은 데이터는 필요할 때만 로드 (lazy 키워드 사용)
5. 큰 데이터는 파일로 저장
	- UserDefaults는 메모리 캐싱을 하기 때문에 FileManager나 Core Data (not in-memory option)을 이용하여 저장
	- NSCache를 사용해 불필요한 데이터 캐싱 방지
		- NSCache는 메모리가 부족하면 자동으로 캐시 삭제
		- 객체를 강하게 참조하지 않음: Key에 대해 약한 참조를 사용 가능하여 키로 사용된 객체가 해제되면 자동으로 캐시 제거
		- 캐시 크기 제한 설정 가능
			- totalCostLimit과 countLimit을 설정하면 지정 용량 초과시 자동으로 오래된 데이터를 삭제함
> [!note]
> ### 23. 알고리즘의 시간 복잡도와 공간 복잡도의 개념, 그리고 빅오 표기법에 대해 설명해주세요.
> - O(n)과 O(log n)의 차이는 무엇인가요?
#### 복잡도
- **알고리즘의 성능을 평가**하는 척도. **시간 복잡도**와 **공간 복잡도**로 나눌 수 있음
- **시간 복잡도**: 특정한 크기의 입력에 대해 알고리즘이 얼마나 오래 걸리는지를 의미
- **공간 복잡도**: 특정한 크기의 입력에 대해 알고리즘이 얼마나 많은 메모리를 차지하는지 의미
#### 빅오 표기법
- 알고리즘의 성능을 표현할 때 **입력 크기 n이 증가할 때의 경향성**을 나타내는 표기법
- 가장 중요한 항만 남기고 상수 및 계수를 무시
**O(n)과 O(log n)의 차이**
- O(n)
	- 선형 시간
	- 입력(n)이 커질수록 실행 시간이 직접적으로 증가
	- 예제 알고리즘: 배열 순회
- O(log n)
	- 로그 시간
	- 입력이 커져도 실행 시간이 완만하게(느리게) 증가
	- 예제 알고리즘: 이진 탐색

> [!note]
> ### 24. 자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도를 설명해주세요.

#### 선택 정렬
- 동작 원리
	- 배열에서 **가장 작은 원소를 찾아** 맨 앞 요소와 교환
	- 두 번째로 작은 원소를 찾아 두 번째 요소와 교환
	- 끝까지 반복
- 시간 복잡도: O(n^2)
- 장점: 구현이 간단하고 메모리 사용량이 적음 (제자리 정렬)
- 단점: 비효율적, 큰 데이터셋에는 부적합
#### 삽입 정렬
- 동작 원리
	- 배열을 왼쪽에서 오른쪽으로 탐색하면서, 현재 원소를 **정렬된 부분에서 적절한 위치를 찾을 때 오른쪽에서 왼쪽으로 비교**
	- 현재 원소보다 큰 값들은 오른쪽으로 이동시키고, 알맞은 위치(현재 원소보다 작은 원소 오른쪽)에 삽입
- 시간 복잡도: O(n^2)
- 장점: 거의 정렬된 데이터는 O(n)으로 매우 빠름
- 단점: 큰 데이터셋에서는 비효율적
#### 버블 정렬
- 동작 원리
	- 인접한 두 원소를 비교하며 교환, 가장 큰 값을 가장 끝으로 보낸다.
	- 한 번 순회할 때마다 정렬된 부분이 확장. (맨 오른쪽부터 정렬됨)
- 시간 복잡도: O(n^2)
- 장점: 구현이 쉽다.
- 단점: 비효율적이다.
#### 병합 정렬
- 동작 원리
	- 분할 정복 알고리즘의 한 종류
	- 배열을 두 개의 부분 배열로 쪼갠다. (Divide)
	- 부분 배열이 충분히 쪼개질 때까지 반복한다.
	- 부분 배열이 충분히 쪼개지면 순서에 맞게 정렬한다. (Conquer)
	- 부분 배열을 하나의 배열로 병합한다. (Merge)
- 시간 복잡도: O(nlogn)
- 장점
	- 안정적인 정렬 방법: 입력 데이터가 어떻든 상관없이 O(nlogn)을 보장
	- 큰 데이터에 유리
- 단점: 추가적인 메모리 공간 필요
#### 퀵 정렬
- 동작 원리
	- 피벗(pivot)을 기준으로 작은 원소들과 큰 원소들의 두 개의 배열로 나눈다.
	- 각각의 부분 배열에 대해 재귀적으로 정렬
	- 최종적으로 정렬된 배열로 병합
- 시간 복잡도: O(nlogn), 최악의 경우 O(n^2) (피벗을 잘못 선택하면)
- 장점: 제자리 정렬 (추가 메모리 사용 적음), 일반적으로 빠름
- 단점: 최악의 경우 O(n^2), 불안정 정렬

> [!note]
> ### 25. 이진 탐색의 원리와 시간 복잡도에 대해 설명해주세요.
#### 이진 탐색
정렬된 배열에서 특정 값을 빠르게 찾는 알고리즘
- 원리
	1. 초기 설정
		- start = 0, end = n - 1
		- 중간 인덱스 mid = (start + end) / 2 계산
	2. 반씩 줄여가며 탐색
		- array[mid] == target -> 찾음, 종료
		- array[mid] > target -> 왼쪽 영역으로 이동 (end = mid - 1)
			- mid 값이 target 값보다 크므로 mid의 오른쪽 영역은 은 모두 target 보다 크기 때문
		- array[mid] < target -> 오른쪽 영역으로 이동 (start = mid + 1)
			- mid 값이 target 값보다 작으므로 mid의 왼쪽 영역은 모두 target 보다 작기 때문
	3. 반복 또는 재귀 호출
		- 더 이상 탐색할 범위가 없으면 종료 (start > end)
- 시간 복잡도: O(logn)
	- 데이터의 크기가 n이면, 반씩 줄어드므로 최대 비교 횟수는 logn
- 반복문과 재귀 모두 구현 가능