> [!note]
> ### 31. 가상 메모리(Virtual Memory)의 개념과 동작 원리에 대해 설명해주세요.
#### 가상 메모리
- **프로세스가 실제 물리적 메모리(RAM)보다 더 많은 메모리를 사용할 수 있도록 지원하는 메모리 관리 기법**
- 가상 주소와 물리 주소를 분리하여 프로세스마다 독립적인 주소 공간 제공
- OS는 **디스크의 일부를 가상 메모리(Swap Space)로 활용**하여 RAM이 부족할 때 프로그램을 계속 실행할 수 있도록 함
	- 하지만 iOS에서는 해당 기능을 제공하지 않음
**가상 메모리의 장점**
- 가상 주소 공간 제공
	- 프로세스마다 독립적인 주소 공간을 할당하여 프로세스 간 메모리 충돌 방지
- 메모리 보호 기능
	- 커널 영역과 사용자 영역을 분리하여 악성 코드가 다른 프로세스를 침범하지 못하도록 보호
- 효율적인 메모리 사용
	- 프로그램의 모든 데이터를 메모리에 로드하지 않고, 필요한 부분만 적재 (Demanding Paging)
#### 동작 원리
**1. 페이징**
- 가상 메모리와 물리 메모리를 **고정된 크기**의 블록(페이지)으로 나누어 관리하는 방식
- 주요 개념
	- 페이지: 가상 메모리를 일정 크기 단위로 나눈 블록
	- 프레임: 물리 메모리를 동일한 크기의 블록으로 나눈 것
	- 페이지 테이블: 가상 주소와 물리 주소를 매핑하는 테이블

**페이징 시스템의 동작 과정**
1. 가상 주소 -> 물리 주소 변환
	- CPU는 가상 주소를 참조
	- MMU(Memory Management Unit)가 페이지 테이블을 이용해 가상 주소를 물리 주소로 변환
2. TLB(Translation Lookaside Buffer) 활용
	- 페이지 테이블 조회 속도를 높히기 위한 캐시 메모리
	- 변환된 주소가 TLB에 존재(TLB Hit)하면 빠르게 접근, 없으면(TLB Miss) 페이지 테이블 조회
3. 페이지 부재(Page Fault) 처리
	- CPU가 요청한 페이지가 물리 메모리에 없으면 page Fault 발생
	- OS는 디스크(SSD/HDD)에서 해당 페이지를 메모리로 로드
	- 디스크 I/O가 발생하므로 성능 저하 가능
4. 페이지 교체 (Page Replacement)
	- 메모리가 가득 찼을 경우, 기존 페이지를 제거 후 새로운 페이지를 적재
	- 대표적인 페이지 알고리즘
		- FIFO(First-In First-Out): 먼저 들어온 페이지부터 제거
		- LRU(Least Recently Used): 가장 오랫동안 사용하지 않은 페이지 제거
		- LFU(Least Frequently Used): 사용 빈도가 가장 낮은 페이지 제거
**2. 세그멘테이션**
- **가상 메모리를 논리적인 크기 단위(세그먼트)로 나누어 관리**
- 코드, 데이터, 스택 등 각각의 영역을 독립적인 세그먼트로 관리
- 페이징과의 주요 차이점
	- 페이징: 고정된 크기의 블록 단위 -> 내부 단편화 발생 가능
	- 세그멘테이션: 가변적인 크기의 블록 단위 -> 외부 단편화 발생 가능
	- 현대 OS는 페이징과 세그멘테이션을 혼합하여 사용.

> [!note]
> ### 32. 데이터베이스의 종류와 iOS에서 주로 사용되는 데이터베이스에 대해 설명해주세요.
#### 데이터베이스의 종류
- 관계형 데이터베이스 (RDB)
	- 데이터를 테이블(표)의 형태로 저장
	- 스키마가 고정되어 있어 **정형 데이터**에 적합
- 비관계형 데이터베이스 (NoSQL)
	- 테이블 형태가 아닌 유연한 데이터 구조(Key-Value, Graph 등)를 사용
	- 스키마가 유동적이라 비정형 데이터(JSON, XML 등)에 적합
#### iOS에서 주로 사용되는 데이터베이스
1. SQLite
	- iOS에서 가장 기본적으로 지원하는 **관계형 데이터베이스**
	- 앱 내부에서 파일 기반 동작
	- 로컬 데이터 저장에 적합
2. Core Data
	- 엄밀히 말하면 데이터베이스가 아닌 객체 그래프 관리 프레임워크
	- SQL을 직접 다루지 않음, 데이터를 객체(Entity)로 다룰 수 있어 편리함
	- XML, Binary, In-Memory 저장소도 지원
3. UserDefaults
	- 간단한 Key-Value 저장소
	- 앱 설정, 사용자 환경 설정 저장 등에 사용
	- 대량의 데이터 저장 용도는 아님
4. Keychain
	- 보안이 중요한 데이터 저장.
5. Cloud 기반 데이터베이스

> [!note]
> ### 33. 싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떤 경우에 사용하나요?
#### 싱글톤 패턴(Singleton Pattern)이란?
하나의 클래스에 대해 단 하나의 인스턴스만 생성되도록 보장하는 디자인 패턴
- 전역적으로 접근 가능
- 반복적으로 객체를 생성할 필요 없이 동일한 인스턴스를 재사용할 수 있다
#### 싱글톤 패턴을 사용하는 경우
1. 전역적으로 하나의 객체만 유지해야 하는 경우
	- 데이터 불일치 문제 방지: 특정 인스턴스에서 설정 값을 변경해도, 다른 인스턴스에는 반영되지 않을 수 있음을 방지
2. 객체 간 데이터 공유가 필요할 때
	- NotificationCenter: 이벤트를 전달하는 객체
	- AppDelegate 또는 SceneDelegate에서 앱의 상태를 관리할 때
3. 리소스를 절약하고, 메모리 사용을 최적화 해야할 때
	- 동일한 역할을 하는 객체를 여러 개 생성하는 대신, 하나만 유지하여 메모리 낭비 방지
#### 싱글톤 패턴의 단점
- 의존성이 높아져 테스트가 어려워질 수 있음
- 멀티스레드 환경에서 동시 접근 문제 발생 가능.

> 싱글톤 패턴은 하나의 클래스에 대해 하나의 인스턴스만 생성되도록 보장하는 디자인 패턴입니다. iOS에서는 네트워크 요청 관리, 데이터 저장, 전역 상태 관리 등의 경우에 주로 사용됩니다. 단, 전역 객체의 남용은 의존성을 높이고 테스트가 어려워지는 단점이 있습니다.

> [!note]
> ### 34. Swift에서 싱글톤 패턴을 구현할 때 멀티스레드에 대해서 어떻게 고려해야 하나요?

Swift에서 싱글톤은 전역적으로 하나의 객체만 유지하므로, 멀티스레드 환경에서 동시에 접근하면 데이터 일관성 문제가 발생할 수 있습니다.
특히, 싱글톤 인스턴스를 여러 스레드에서 동시에 생성하려 하면 예상치 못한 버그가 발생할 수 있습니다.
#### Thread-Safe를 보장하는 방법
1. static let 사용
	- Swift의 Static let은 자동으로 Thread-Safe하게 동작하기 때문에 **Read-only** 상황에서는 이정도로 충분합니다.
2. Actor 사용 (Swift 5.5 이상)
	- actor를 사용하면 동기화 문제를 걱정할 필요 없이 안전하게 멀티스레드에서 데이터를 관리 할 수 있습니다.
3. NSLock 또는 Serial DispatchQueue 활용
	- Swift Concurrency를 사용할 수 없는 경우, NSLock이나 DispatchQueue(label:) 을 이용하여 데이터 접근을 동기화 할 수 있습니다.


> [!note]
> ### 35. Array와 List의 차이점이 무엇인지 설명해주세요.

