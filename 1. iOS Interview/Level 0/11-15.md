> [!note]
> ### 11. **HTTP와 HTTPS의 차이점, 그리고 iOS에서의 보안 통신 방법에 대해 설명해주세요.**
> - SSL/TLS의 동작 원리는 무엇인가요?

**HTTP와 HTTPS의 차이점**
- HTTP와 HTTPS는 클라이언트와 서버 간 통신을 위한 통신 규약 입니다.
- HTTP의 패킷은 보안되어 있지 않아서 외부에서 정보를 확인할 수 있습니다. HTTPS의 경우 패킷이 암호화되어 외부에서는 패킷의 내용을 알 수 없다는 차이가 있습니다.
**iOS에서의 보안 통신 방법**
- App Transport Security (ATS)
	- iOS 9 부터 기본적으로 **HTTPS만 허용**
	- Info.plist에서 ATS를 비활성화 하면 예외적으로 HTTP를 사용할 수 있다.
- SSL/TLS 암호화 적용
	- URLSession을 사용하면 iOS에서 자동으로 TLS 1.2 이상을 적용
	- 보안 강화를 위해 **SSL Pinning**을 사용할 수 있다.
- SSL Pinning (공개키 고정, 인증서 고정)
	- 공격자가 가짜 인증서를 사용해 중간에서 데이터를 탈취하는 Man-In-The-Middle(중간자 공격) 공격을 방지
	- iOS에서 SSL Pinning을 적용하는 방법
		- 앱 내부에 신뢰할 인증서의 **공개키** 저장
		- 서버 인증서의 공개키와 앱 내 저장된 공개키 비교
		- 일치하면 통신 허용, 불일치 시 차단
**SSL/TLS의 동작 원리**
- SSL과 TLS는 사실상 같다고 볼 수 있다. SSL을 업그레이드 한 것이 TLS이기 때문이다. 하지만 현재 SSL은 사용하지 않고 TLS 1.2, 1.3을 사용한다.
1. Handshake 과정
	1. 클라이언트 (iOS 앱) -> 서버: 지원하는 암호화 방식 목록 전달.
	2. 서버 -> 클라이언트: SSL/TLS 인증서 
		- 해당 인증서에는 서버의 신원을 증명하는 정보와 공개키가 포함
	3. 클라이언트 인증서 검증: 신뢰할 수 있는 CA(인증 기관)인지 확인
	4. 암호화 키 생성: 서버와 클라이언트가 세션 키를 교환하고 보안 연결을 확립
2. 데이터 전송 (암호화된 HTTPS 통신 시작)
	1. 이후 모든 데이터는 TLS 암호화 방식으로 암호화되어 전송

> [!note]
> ### 12. **컴퓨터 네트워킹에서 OSI 7계층 모델에 대해 설명해주세요.**
> - 각 계층의 역할과 프로토콜은 무엇인가요?
> - TCP/IP 모델과 OSI 모델의 차이점은 무엇인가요?

**OSI 7계층**
- 응용 계층 (Application Layer)
	- 사용자가 직접 접근하는 계층, 네트워크 서비스 제공
	- **프로토콜**: HTTP, HTTPS, FTP, SMTP, DNS
- 표현 계층 (Presentation Layer)
	- 전송하는 데이터의 표현 방식을 결정 (데이터의 형식 변환, 암호화, 압축 등)
	- 기능: 데이터 인코딩/ 디코딩, 암호화/복호화, 데이터 압축
	- 예시: SSL/TLS 암호화, JPEG, MP4 포맷 변환
- 세션 계층 (Session Layer)
	- 통신의 설정, 유지, 종료를 관리
	- 예시: 로그인 유지 기능, API 세션 관리
- 전송 계층 (Transport Layer)
	- 데이터의 **신뢰성** 있는 전송 보장, 오류 검출 및 복구 처리
	- 프로토콜: TCP (신뢰성 보장), UDP (빠른 속도)
- 네트워크 계층 (Network Layer)
	- 데이터를 목적지까지 **최적의 경로를 찾아 패킷을 전달** (라우팅)
	- **패킷** 단위
	- 프로토콜: IP, ICMP, ARP
	- 해당 장비로는 라우터가 있다.
- 데이터 링크 계층 (DataLink Layer)
	- 프레임 단위로 데이터를 주고받으며, 오류 검출 및 프레임 흐름 제어 수행
	- **프레임** 단위
	- 프로토콜: 이더넷, Wi-Fi
	- 해당 장비로는 이더넷, 브리지, 스위치 등이 있다.
	-> 프레임에 주소 부여(MAC - 물리적 주소), 에러 검출 / 재전송 / 흐름 제어
- 물리 계층 (Physical Layer)
	- 실제 물리적 신호를 담당
	- 0과 1의 **비트** 단위
	- 해당 장비로는 LAN, 광 케이블 등이 있다.
	-> 케이블, 리피터, 허브 등을 통해 데이터를 전송한다.

**TCP/IP 모델**
- 응용 계층 (Application Layer)
	- HTTP, HTTPS, FTP 등 사용자와 직접 접하는 계층
- 전송 계층 (Transport Layer)
	- 데이터의 신뢰성 보장과 흐름 제어 담당
	- 프로토콜: TCP (신뢰성 보장), UDP (빠른 속도)
- 인터넷 계층 (Internet Layer)
	- IP 주소 지정과 데이터 패킷을 목적지까지 라우팅 하는 역할
	- 프로토콜: IP (주소 지정), ICMP (오류 처리)
- 네트워크 인터페이스 계층 (Network Interface Layer)
	- 물리적 네트워크 인터페이스와 직접 연결 (이더넷, Wi-Fi, MAC 주소)

**TCP/IP 모델과 OSI 7계층의 차이점**

| 구분             | OSI 7계층 | TCP/IP 4계층         |
| -------------- | ------- | ------------------ |
| 이론/실제          | 이론적 모델  | 실제 인터넷에서 사용        |
| 계층 수           | 7개      | 4개                 |
| 표현/세션 계층       | 따로 존재   | 응용 계층에 포함          |
| 데이터 링크 + 물리 계층 | 분리됨     | 네트워크 인터페이스 계층으로 통합 |

> [!note]
> ### 13. **HTTP 프로토콜의 특징과 HTTP/1.1과 HTTP/2의 차이점을 설명해주세요.**
> - HTTP의 무상태(Stateless) 성질은 무엇이며, 어떻게 극복하나요?
> - HTTP/2 에서 추가된 주요 기능은 무엇인가요?
> - HTTP/3 에서 추가된 기능은 무엇인가요?

**HTTP 프로토콜의 특징**
- **Client - Sever 구조**
- **무상태 (Stateless)**: 서버에서 클라이언트의 상태를 저장하지 않는다.
	- 이를 해결하기 위해 **쿠키, 세션, JWT, 토큰 기반 인증** 등을 사용하여 상태 유지
- HTTP/1.0
	- **연결 하나당 요청 하나를 처리**하도록 설계되어 RTT 시간이 증가
		- 연결시마다 3-way handshake를 해주어야 했기 때문
- HTTP/1.1
	- HTTP/1.0에서 매번 요청시마다 연결을 해주는 방식에서 RTT 가 증가하는 문제를 해결하기 위해 TCP **연결을 재사용**하여 연결 1번에 요청을 여러 번 수행할 수 있게 되었다.
	- **HoL** (Head of Line) 이라는 병목 현상이 발생함.
		- HoL: 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하.
	- **무거운 헤더 구조**: 쿠키 등 많은 메타데이터가 들어있어 무거우나 압축이 되지 않아 무거움
- HTTP/2
	- **헤더 압축**: 무거운 헤더 구조를 개선하기 위해 허프만 인코딩으로 헤더 압축
	- **멀티플렉싱**: 여러 개의 스트림을 사용하여 송수신
		- 특정 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 끼치고 나머지는 정상 동작
	- 서버 푸시: HTTP/1.1에서는 클라이언트가 서버에 요청을 해야만 파일을 다운받을 수 있었으나, HTTP/2 에서는 **클라이언트 요청 없이 서버가 바로 리소스 푸시** 가능
- HTTP/3.0
	- UDP 기반 QUIC 프로토콜 사용: TCP의 3-way handshake 없이 1-RTT 연결 설정 하여 **더 빠른 연결 속도**
	- 개별 스트림 재전송: 패킷 손실 시 개별 스트림만 재전송하여 **속도 향상**
	- TCP 대신 UDP 기반으로 변경하여 HoL 블로킹을 제거함

> [!note]
> ### 14. **TCP와 UDP의 특징과 차이점에 대해 설명해주세요.**
> - 연결 지향형 프로토콜과 비연결 지향형 프로토콜은 무엇인가요?
> - TCP의 3-way handshake 과정은 어떻게 이루어지나요?
> - 어떤 상황에서 UDP를 사용하는 것이 적합한가요?

**TCP**
- **연결 지향형(Connection-oriented) 프로토콜**
	- 통신 전에 3-way handshake를 통해 연결을 설정하고, 4-way handshake를 통해 연결을 해제함
- 신뢰성 보장
	- 패킷 손실 시 **재전송**(ACK, Timeout) 을 통해 보장
	- 순서 보장 (Sequencing): 패킷 순서가 뒤섞이지 않음
	- 흐름 제어 (Flow Control): 수신 측이 감당할 수 있는 속도로 데이터 전송 조절
	- 혼잡 제어 (Congestion Control): 네트워크 혼잡을 방지하기 위해 전송 속도를 조절 (패킷 로스로 확인)
- 3-way handshake
	- 클라이언트 -> 서버: SYN (연결 요청)
	- 서버 -> 클라이언트: SYN + ACK 전송 (요청 수락 및 응답)
	- 클라이언트 -> 서버: ACK (연결 확정)
- 4-way handshake
	- 클라이언트 -> 서버: FIN (연결 종료 요청)
	- 서버 -> 클라이언트: ACK (요청 확인)
	- 서버 -> 클라이언트: FIN (서버도 종료 요청)
	- 클라이언트 -> 서버: ACK (서버 종료 확인, 이후 연결 해제)
**UDP**
- **비연결 지향형(Connectionless) 프로토콜**
	- 핸드셰이크 과정 없이 데이터를 바로 전송
	- 신뢰성을 보장하지 않음 (순서 보장 X, 재전송 X)
- 빠른 속도
	- 패킷 손실을 감수하고 속도를 최우선
	- 작은 오버헤드 -> 실시간 통신에 적합
- 빠른 응답이 중요한 실시간 스트리밍, 온라인 게임, VoIP (e.g.Zoom)에 적합

> [!note]
> ### 15. **소켓 통신에 대해 설명해주세요.**

